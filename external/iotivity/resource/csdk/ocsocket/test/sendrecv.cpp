//******************************************************************
//
// Copyright 2014 Intel Mobile Communications GmbH All Rights Reserved.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/select.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <fcntl.h>
#include <net/if.h>

#include <ifaddrs.h>
#include <linux/if_link.h>

#include <signal.h>

//static uint8_t MULTICAST_IP_ADDR[] = {224, 0, 1, 187};
//static uint32_t TEST_PORT_NUM = 8888;


#define MAX_BUF (1024)
uint8_t g_bfr[] = {
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA,
    };
uint32_t g_bfrlen = sizeof(g_bfr);

int multicast_test(int argc, char* argv[])
{
    int32_t sfd;
    char loopch=0;
    int set_option_on = 1;
    struct sockaddr_in mcastsock = {0}, peer;
    uint8_t recvbuf[MAX_BUF];
    uint32_t len, bufLen, fromlen;

    printf("Running multicast tests\n");

    bufLen = atoi(argv[4]);
    if (bufLen > g_bfrlen) {
        printf("Warning: Input buffer provided too big. Trimming to supported size\n");
        bufLen = g_bfrlen;
    }

    //Create a datagram socket on which to send.
    sfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sfd < 0) {
        printf("Error in opening datagram socket");
        return -1;
    }

    //Initialize the group sockaddr structure with a
    mcastsock.sin_family = AF_INET;
    mcastsock.sin_addr.s_addr = inet_addr(argv[2]);
    mcastsock.sin_port = htons(atoi(argv[3]));

    //Disable loopback so you do not receive your own datagrams.
    if (setsockopt(sfd, IPPROTO_IP, IP_MULTICAST_LOOP,
                (char *)&loopch, sizeof(loopch)) < 0) {
        //printf("setting IP_MULTICAST_LOOP:");
        close(sfd);
        return -1;
    }

    //Play nice with other processes who may be listening at this
    //port/IP address combination
    if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (char*) &set_option_on,
                sizeof(set_option_on)) < 0) {
        //printf("setting SO_REUSEADDR:");
        close(sfd);
        return -1;
    }

    if (bind(sfd, (sockaddr*)&mcastsock, sizeof(mcastsock)) < 0) {
        printf("bind returns error");
        close(sfd);
        return -1;
    }

    struct ip_mreq mreq = {0};
    mreq.imr_interface.s_addr = htonl(INADDR_ANY);
    mreq.imr_multiaddr.s_addr = mcastsock.sin_addr.s_addr;
    if ((setsockopt(sfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char *) &mreq, sizeof(mreq))) < 0) {
        printf("multicast -- adding membership failed");
        close(sfd);
        return -1;
    }

    do {
        len = sendto(sfd, g_bfr,  bufLen, 0,
                (struct sockaddr*)&mcastsock, sizeof(mcastsock));
        if (len > 0) {
            printf ("Send %d bytes to %s\n", len, inet_ntoa(mcastsock.sin_addr));
        }

        fromlen = sizeof(peer);
        len = recvfrom(sfd, recvbuf, sizeof(recvbuf), 0, (struct sockaddr*)&peer, &fromlen);
        if (len > 0) {
            printf("Rcvd %d bytes from %s\n", len, inet_ntoa(peer.sin_addr));
        }

        sleep(1);
    } while (true);

    close(sfd);
    return 0;
}




int unicast_test(int argc, char* argv[])
{
    int32_t sfd;
    struct sockaddr_in sa, peer;
    uint8_t recvbuf[MAX_BUF];
    uint32_t len, bufLen, fromlen;

    printf("Running unicast tests\n");

    bufLen = atoi(argv[4]);
    if (bufLen > g_bfrlen) {
        printf("Warning: Input buffer provided too big. Trimming to supported size\n");
        bufLen = g_bfrlen;
    }

    sfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sfd < 0) {
        printf("socket API ret val %d\n", sfd);
        return -1;
    }

    sa.sin_family = AF_INET;
    sa.sin_addr.s_addr = INADDR_ANY;
    sa.sin_port = htons(atoi(argv[3]));

    if (bind(sfd, (struct sockaddr*)&sa, sizeof(sa)) < 0) {
        printf("bin API ret val %d\n", sfd);
        close(sfd);
        return -1;
    }

    peer.sin_family = AF_INET;
    inet_aton(argv[2], &peer.sin_addr);
    peer.sin_port = htons(atoi(argv[3]));

    do {
        len = sendto(sfd, g_bfr,  bufLen, 0,
                (struct sockaddr*)&peer, sizeof(peer));

        if (len > 0) {
            printf ("Send %d bytes to %s\n", len, inet_ntoa(peer.sin_addr));
        }

        fromlen = sizeof(peer);
        len = recvfrom(sfd, recvbuf, sizeof(recvbuf), 0, (struct sockaddr*)&peer, &fromlen);
        if (len > 0) {
            printf("Rcvd %d bytes from %s\n", len, inet_ntoa(peer.sin_addr));
        }

        sleep(1);
    } while(true);

    close(sfd);
    return 0;
}




int main(int argc, char * argv[])
{

    if (argc < 5) {
        printf("Usage: sendrecv <u|m> <ipAddr 192.168.1.107 | 224.0.1.187> <portnum 8888> <pkt_size 200>\n");
        return -1;
    }

    if (argv[1][0] == 'u') {
        unicast_test(argc, argv);
    } else {
        multicast_test(argc, argv);
    }

    return 0;
}
